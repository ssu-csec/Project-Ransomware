# ===== 32-bit CALL (cdecl/stdcall 공통) with sentinel-return =====
SENTINEL_RET32 = 0xDEADBEEF

def _u32(x: int) -> bytes:
    return (x & 0xFFFFFFFF).to_bytes(4, "little")

def before_execution_cb_32(sess: bochscpu.Session, cpu_id: int, _: int):
    # 32비트: EIP가 센티넬 주소로 '리턴'되면 중단
    if sess.cpu.eip == SENTINEL_RET32:
        logging.debug(f"[CPU#{cpu_id}] Reached sentinel return @ {SENTINEL_RET32:#x}, stopping")
        sess.stop()

def call_function_32(
    sess: bochscpu.Session,
    func_va: int,           # 덤프 내 함수 시작 VA (예: CRYPTBASE base + export RVA)
    args: list[int],        # 인자들(왼→오). cdecl/stdcall 모두 스택 push
    stack_va: int,          # 미리 RW로 매핑한 스택 가상주소 (페이지 시작)
    stack_size: int = 0x1000,
) -> None:
    """
    - 스택 top을 확보하고,
    - [SENTINEL_RET32]를 '리턴 주소'로 푸시,
    - args를 역순으로 push,
    - EIP=func_va로 점프.
    - before_execution_cb_32가 sentinel에 도달하면 정지.
    """
    # 1) 훅 준비(예외는 옵션)
    hook = bochscpu.Hook()
    hook.before_execution = before_execution_cb_32
    hook.exception = exception_cb  # 네가 쓰던 기존 콜백 재사용 (원하면 생략 가능)

    state = sess.cpu.state

    # 2) 스택 포인터 준비 (여유를 넉넉히, 16바이트 정렬까지 하고 싶으면 & ~0xF)
    sp = stack_va + stack_size - 0x40  # 여유 64B
    # sp &= ~0xF  # (선택) 16-byte 정렬

    # 3) sentinel return 주소 push (함수 ret 시 여기로 '돌아오게')
    sp -= 4
    bochscpu.memory.virt_write(PML4_ADDRESS, sp, _u32(SENTINEL_RET32))

    # 4) 인자들을 '역순'으로 push  (cdecl/stdcall 동일)
    for a in reversed(args):
        sp -= 4
        bochscpu.memory.virt_write(PML4_ADDRESS, sp, _u32(a))

    # 5) 레지스터 설정
    state.eip = func_va
    state.esp = sp

    # 6) 상태 반영 및 실행
    sess.cpu.state = state
    sess.run([hook])
